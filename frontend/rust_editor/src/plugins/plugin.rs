use std::any::Any;

use geo::Coordinate;
use rust_internal::PluginExecutionBehaviour;
use web_sys::CanvasRenderingContext2d;
use yew::{html, Context, Html};


use crate::ui::app::{App, EditorError, Shortkey};

pub trait AnyPlugin<Data>: Plugin<Data>
where
    Data: Default + 'static,
{
    fn as_any(&self) -> &dyn Any;
    fn as_any_mut(&mut self) -> &mut dyn Any;
}

#[derive(PartialEq)]
pub enum SpecialKey {
    Ctrl,
    Shift,
    Alt,
}

/// Option trait for a plugin.
///
/// It provides functions that handle displaying properties of a plugin and reacting on changes of the ui when the user
/// wants to alter a property.
///
/// It is higly recommended not to implement this trait for your plugin by yourself. Instead use the provided derive macro called Plugin.
///
/// # Example
///
/// ```
/// /* 
/// TODO: cargo test fails here, reenable it later
/// #[derive(Plugin)]
/// pub struct Grid {
///     #[option(default=10, min=0, max=2000, label="Offset", description="The offset between two grid lines.")]
///     offset: u32,

///     #[option(default=2, min=0, max=100, label="Subdivisions", description="Subdivisions between offset")]
///     subdivisions: u8,
/// }
/// */
/// ```
///
/// The plugin will autogenerated the functions for you resulting in a consistent ui and proven functionality with standartized error handling.
///
#[allow(unused_variables)]
pub trait PluginWithOptions<Data>: AnyPlugin<Data>
where
    Data: Default + 'static,
{
    /// Renders the ui elements for all plugin options
    fn view_options(&self, _context: &Context<App<Data>>) -> Html {
        html! {}
    }

    /// Called each time a property is updated. Use it to message the change or apply it to the plugin directly.
    fn update_property(&mut self, _property: &str, _value: Box<dyn Any>) {}

    fn identifier() -> &'static str
    where
        Self: Sized;

    /// Returns true if the plugin is currently enabled, false otherwise
    fn enabled(&self) -> bool;

    /// Enables the plugin in the editor.
    /// Note that calling this function does not disables the current enabled plugin if the execution behaviour is exclusive. This is
    /// done within the editor.
    fn enable(&mut self);

    /// Disables the plugin in the editor.
    fn disable(&mut self);

    /// Returns the execution behaviour of the plugin.
    fn execution_behaviour(&self) -> &PluginExecutionBehaviour;
}

#[allow(unused_variables)]
pub trait Plugin<Data>
where
    Data: Default,
{
    /// Is used to implement behaviour of the state if the user clicked inside the specified
    /// html element by the statemachine.
    ///
    /// * `x` - x coordinate of the cursor where the click occured
    /// * `y` - x coordinate of the cursor where the click occured
    /// * `button` - The number of the pressed button (0=left, 1=middle, 2=right) [See here for more informations](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button)
    fn mouse_down(&mut self, mouse_pos: Coordinate<f64>, button: u32, editor: &App<Data>) {}

    /// Is used to implement behaviour of the state if the user moved the cursor inside the
    /// specified html element by the statemaschine.
    ///
    /// * `x` - x coordinate of the cursor where the click occured
    /// * `y` - x coordinate of the cursor where the click occured
    fn mouse_move(
        &mut self,
        mouse_pos: Coordinate<f64>,
        mouse_movement: Coordinate<f64>,
        editor: &mut App<Data>,
    ) {
    }

    fn render(&self, context: &CanvasRenderingContext2d, editor: &App<Data>) {}

    /// Is used to implement behaviour of the state if the user released a pressed mouse button
    /// inside the specified html element by the statemachine.
    ///
    /// * `x` - x coordinate of the cursor where the click occured
    /// * `y` - x coordinate of the cursor where the click occured
    /// * `button` - The number of the pressed button (0=left, 1=middle, 2=right) [See here for more informations](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button)
    /// * `data` - The data hold by the editor
    fn mouse_up(&mut self, _mouse_pos: Coordinate<f64>, _button: u32, editor: &mut App<Data>) {}

    /// React to a key held down on a keyboard.  
    ///
    /// * 'key' the value of the pressed key. [See here for more informations](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
    /// * `data` - The data hold by the editor
    fn key_down(&mut self, key: &str, editor: &mut App<Data>) {}

    /// React to a key released on a keyboard.  
    ///
    /// * 'key' the value of the released key. [See here for more informations](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
    /// * `data` - The data hold by the editor
    fn key_up(&mut self, key: &str, editor: &mut App<Data>) {}

    /// Is triggered if a shortkey is pressed that is registered with the associated plugin. Notice the difference to key_down or key_press function:
    /// While key_down or key_press react on single key events, shortkey_pressed is not a native web event instead pressed keys are aggregated by the
    /// editor and checked against registered shortkeys. If the pressed shortkey exists in one plugin and the plugin is active than only this function
    /// is called.
    fn shortkey_pressed(&mut self, key: &Shortkey, ctx: &Context<App<Data>>, editor: &mut App<Data>) {}

    fn property_updated(&mut self, property: &str, editor: &mut App<Data>) {}

    /// Called once before the plugin is added to the editor list of plugins. You can use this it to add additional ui elements such as toolbars (and buttons) or
    /// register shortkeys for the plugin.
    fn startup(&mut self, editor: &mut App<Data>) -> Result<(), EditorError> {
        Ok(())
    }

    fn activated(&mut self, editor: &mut App<Data>) -> Result<(), EditorError> {
        Ok(())
    }

    fn deactivated(&mut self, editor: &mut App<Data>) -> Result<(), EditorError> {
        Ok(())
    }
}