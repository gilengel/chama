#![allow(warnings)]


use std::collections::HashMap;

use plugins::{plugin::{Plugin, PluginWithOptions}, camera::Renderer};
use core::hash::Hash;

pub mod actions;
pub mod gizmo;
pub mod interactive_element;
pub mod macros;
pub mod plugins;
pub mod renderer;
pub mod store;
pub mod style;
pub mod system;
pub mod ui;

#[derive(PartialEq)]
pub enum InformationLayer {
    Debug,
}

pub fn get_plugin<'a, Data, Modes, P>(plugins: &'a HashMap<&'static str, Box<(dyn PluginWithOptions<Data, Modes> + 'static)>>) -> Option<&'a P>
where
    P: PluginWithOptions<Data, Modes> + 'static,
    Modes: Eq + Hash + Clone + 'static,
    Data: Default + Renderer + 'static,
{
    let id = P::identifier();
    if plugins.contains_key(id) {
        // We do the unwrap and rewrapping in Some becase we can be sure that the plugin is of type S since the identifier method
        // is autogenerated and produces unique identifiers for each plugin
        return Some(plugins.get(id).unwrap().as_ref().as_any().downcast_ref::<P>().unwrap());
    }

    None
}

pub fn get_plugin_mut<Data, Modes>(plugins: &mut Vec<Box<dyn PluginWithOptions<Data, Modes>>>) -> Option<&mut Modes>
where
    Modes: 'static,
    Data: Renderer + 'static,
{
    todo!()
}